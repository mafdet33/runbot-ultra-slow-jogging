# ================================================================
#   RunBot è¶…æ…¢è·‘åŠ©æ‰‹ï¼ˆä¸»è¦–è¦º + ç™½å¡ç‰‡ + å®Œæ•´å°æ¸¬é©—ï¼‰
#   Final Version - Fully Working
# ================================================================

import os
import json
import random
import sqlite3
from datetime import datetime, timedelta

from flask import Flask, request, abort, send_from_directory, jsonify
from dotenv import load_dotenv

# LINE v2 SDK
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import (
    MessageEvent, TextMessage, TextSendMessage,
    PostbackEvent,
    FlexSendMessage, ImageSendMessage
)

# ---------------------------------------------------------------
#                 Load environment variables
# ---------------------------------------------------------------
load_dotenv()
LINE_CHANNEL_SECRET = os.getenv("LINE_CHANNEL_SECRET")
LINE_CHANNEL_ACCESS_TOKEN = os.getenv("LINE_CHANNEL_ACCESS_TOKEN")

# ä½ çš„å›ºå®š ngrok domain
NGROK = "https://unstarved-consentaneous-estella.ngrok-free.dev"

if not LINE_CHANNEL_SECRET or not LINE_CHANNEL_ACCESS_TOKEN:
    print("âŒ ERROR: Missing LINE keys (.env æœªè¨­å®šå®Œæ•´)")

app = Flask(__name__)
line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

DB_PATH = "quiz.db"
EDU_PATH = "content/education.json"
QUIZ_PATH = "content/quiz.json"


# ================================================================
#                     Health Check & Static
# ================================================================
@app.route("/", methods=["GET"])
def health():
    return jsonify({"ok": True})


@app.route("/content/<path:filename>")
def serve_content(filename):
    return send_from_directory("content", filename)


# ================================================================
#                        LINE Webhook
# ================================================================
@app.route("/webhook", methods=["POST"])
def webhook():
    signature = request.headers.get("X-Line-Signature", "")
    body = request.get_data(as_text=True)

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)

    return "OK"


# ================================================================
#                           Database
# ================================================================
def init_db():
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()

        c.execute("""
        CREATE TABLE IF NOT EXISTS quiz_state(
            user_id TEXT PRIMARY KEY,
            q_list TEXT,
            idx INTEGER DEFAULT 0,
            score INTEGER DEFAULT 0,
            started_at TEXT
        )
        """)

        c.execute("""
        CREATE TABLE IF NOT EXISTS quiz_result(
            user_id TEXT,
            score INTEGER,
            total INTEGER,
            percent INTEGER,
            finished_at TEXT
        )
        """)

        c.execute("""
        CREATE TABLE IF NOT EXISTS run_log(
            user_id TEXT,
            run_date TEXT
        )
        """)

        conn.commit()


# ================================================================
#                          Utilities
# ================================================================
def load_json(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)
    
def load_mohw_group():
    path = "content/mohw_grouped.json"
    if not os.path.exists(path):
        return {}
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def send_mohw_article(uid, articles, idx):
    a = articles[idx]

    title = a["title"]
    content = a["content"][:300] + "..." if len(a["content"]) > 300 else a["content"]
    cat = a.get("category", "ç„¡åˆ†é¡")

    bubble = {
        "type": "bubble",
        "body": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {"type": "text", "text": title, "weight": "bold", "wrap": True},
                {"type": "text", "text": content, "wrap": True, "margin": "md"},
            ]
        },
        "footer": {
            "type": "box",
            "layout": "horizontal",
            "contents": [
                {
                    "type": "button",
                    "style": "secondary",
                    "action": {
                        "type": "postback",
                        "label": "ä¸Šä¸€ç¯‡",
                        "data": f"mohw_prev:{cat}:{idx}"
                    }
                },
                {
                    "type": "button",
                    "style": "secondary",
                    "action": {
                        "type": "postback",
                        "label": "ä¸‹ä¸€ç¯‡",
                        "data": f"mohw_next:{cat}:{idx}"
                    }
                }
            ]
        }
    }

    line_bot_api.reply_message(event.reply_token, FlexSendMessage(title, bubble))
    return



def get_random_article(key):
    data = load_json(EDU_PATH)
    arr = data.get(key, [])
    if not arr:
        return {"title": "å°šç„¡è³‡æ–™", "content": "è«‹ç¨å¾Œå†è©¦ï½"}
    return random.choice(arr)

def mohw_category_menu():
    bubble = {
        "type": "carousel",
        "contents": []
    }

    categories = ["é—¢è¬ ", "è€äººå¥åº·", "å…’ç«¥å¥åº·", "é‹å‹•ä¿ƒé€²", "é£²é£Ÿèˆ‡ç‡Ÿé¤Š"]

    for cat in categories:
        card = {
            "type": "bubble",
            "size": "micro",
            "body": {
                "type": "box",
                "layout": "vertical",
                "contents": [
                    {"type": "text", "text": cat, "weight": "bold", "size": "md"}
                ]
            },
            "footer": {
                "type": "box",
                "layout": "vertical",
                "contents": [
                    {
                        "type": "button",
                        "action": {
                            "type": "postback",
                            "label": "æŸ¥çœ‹",
                            "data": f"mohw_cat:{cat}"
                        }
                    }
                ]
            }
        }
        bubble["contents"].append(card)

    return FlexSendMessage("åˆ†é¡é¸å–®", bubble)
   
    

# ================================================================
#                    Main Menu (image + card)
# ================================================================
def main_visual():
    url = f"{NGROK}/content/images/run.png"
    return ImageSendMessage(url, url)


def menu_flex():
    bubble = {
        "type": "bubble",
        "size": "mega",
        "body": {
            "type": "box",
            "layout": "vertical",
            "spacing": "md",
            "contents": [
                {"type": "text", "text": "RunBot è¶…æ…¢è·‘åŠ©æ‰‹ ğŸƒâ€â™€ï¸", "weight": "bold", "size": "xl"},
                {
                    "type": "text",
                    "text": (
                        "å—¨ï½æˆ‘æ˜¯ä½ çš„ RunBot è¶…æ…¢è·‘åŠ©æ‰‹ã€‚\n"
                        "æˆ‘å¯ä»¥é™ªä½ èªè­˜è¶…æ…¢è·‘ã€é£²é£Ÿå»ºè­°ï¼Œä¹Ÿèƒ½å’Œä½ ä¸€èµ·åšå°æ¸¬é©—ï¼\n\n"
                        "ä»»ä½•æ™‚å€™è¼¸å…¥ã€Œé–‹å§‹ã€éƒ½èƒ½å›åˆ°é€™è£¡ ğŸ˜Š"
                    ),
                    "wrap": True,
                    "margin": "md"
                }
            ]
        },
        "footer": {
            "type": "box",
            "layout": "vertical",
            "spacing": "sm",
            "contents": [
                {"type": "button", "style": "secondary", "action": {"type": "postback", "label": "é—œæ–¼è¶…æ…¢è·‘", "data": "menu:about"}},
                {"type": "button", "style": "secondary", "action": {"type": "postback", "label": "é£²é£Ÿå»ºè­°", "data": "menu:diet"}},
                {"type": "button", "style": "secondary", "action": {"type": "postback", "label": "é‹å‹•å»ºè­°", "data": "menu:exercise"}},
                {"type": "button","style": "secondary","action": {"type": "message", "label": "åœ‹å¥ç½²æ–‡ç« ", "text": "åœ‹å¥ç½²æ–‡ç« "}},
                {"type": "button", "style": "secondary", "action": {"type": "postback", "label": "å°æ¸¬é©—", "data": "quiz:start"}},
                {"type": "button", "style": "secondary", "action": {"type": "message", "label": "æˆ‘ä»Šå¤©æœ‰é‹å‹•", "text": "æˆ‘ä»Šå¤©æœ‰é‹å‹•"}},
                {"type": "button", "style": "secondary", "action": {"type": "message", "label": "æœ¬é€±çµ±è¨ˆ", "text": "æœ¬é€±çµ±è¨ˆ"}},

            ]
        }
    }
    return FlexSendMessage("ä¸»é¸å–®", bubble)


# ================================================================
#                        Quiz Logic
# ================================================================
def start_quiz(uid):
    quiz_all = load_json(QUIZ_PATH)
    selected = random.sample(quiz_all, 5) if len(quiz_all) >= 5 else quiz_all

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("""
        REPLACE INTO quiz_state(user_id, q_list, idx, score, started_at)
        VALUES (?, ?, ?, ?, ?)
        """, (uid, json.dumps(selected, ensure_ascii=False), 0, 0, datetime.utcnow().isoformat()))
        conn.commit()


def get_quiz_state(uid):
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT q_list, idx, score FROM quiz_state WHERE user_id=?", (uid,))
        row = c.fetchone()

    return (json.loads(row[0]), row[1], row[2]) if row else None


def update_quiz_state(uid, idx, score):
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("UPDATE quiz_state SET idx=?, score=? WHERE user_id=?", (idx, score, uid))
        conn.commit()


def send_quiz_question_reply(event, qdata, idx):
    """reply_message ç”¨ï¼ˆç¬¬ä¸€é¡Œç”¨ï¼‰"""
    flex = build_quiz_bubble(qdata, idx)
    line_bot_api.reply_message(event.reply_token, flex)


def send_quiz_question_push(uid, qdata, idx):
    """push_message ç”¨ï¼ˆå¾€ä¸‹ä¸€é¡Œï¼‰"""
    flex = build_quiz_bubble(qdata, idx)
    line_bot_api.push_message(uid, flex)


def build_quiz_bubble(qdata, idx):
    q = qdata[idx]
    bubble = {
        "type": "bubble",
        "size": "mega",
        "body": {
            "type": "box",
            "layout": "vertical",
            "spacing": "md",
            "contents": [
                {"type": "text", "text": f"é¡Œç›® {idx+1}/{len(qdata)}", "weight": "bold", "size": "xl"},
                {"type": "text", "text": q["question"], "wrap": True, "margin": "md"}
            ]
        },
        "footer": {
            "type": "box",
            "layout": "vertical",
            "spacing": "sm",
            "contents": []
        }
    }

    for i, opt in enumerate(q["options"]):
        bubble["footer"]["contents"].append({
            "type": "button",
            "style": "secondary",
            "action": {"type": "postback", "label": opt, "data": f"quiz:ans:{idx}:{i}"}
        })

    return FlexSendMessage("å°æ¸¬é©—", bubble)


def feedback(ok):
    if ok:
        return random.choice([
            "âœ¨ å¤ªæ£’äº†ï¼ç¹¼çºŒä¿æŒï½",
            "ğŸ’ª ç­”å°äº†ï¼ä½ çœŸçš„å¾ˆæ£’ï¼",
            "ğŸ‰ å®Œå…¨æ­£ç¢ºï¼"
        ])
    return random.choice([
        "ğŸŒ± æ²’é—œä¿‚ï¼Œæˆ‘å€‘ä¸€èµ·æ…¢æ…¢ä¾†ï½",
        "ğŸ¤” å°å°å¤±èª¤ä¹Ÿæ²’é—œä¿‚ï¼Œä¸‹é¡Œå†æŒ‘æˆ°ï¼",
        "ğŸ’¡ å†çœ‹çœ‹ä¸‹ä¸€é¡Œå§ï¼"
    ])


# ================================================================
#                  Postback Handler
# ================================================================
@handler.add(PostbackEvent)
def handle_postback(event):
    data = event.postback.data
    uid = event.source.user_id

    # ä¸»é¸å–®
    if data.startswith("menu:"):
        key = data.split(":", 1)[1]
        fake = MessageEvent(
        reply_token=event.reply_token,
        source=event.source,
        message=TextMessage(text=key)
    )
        handle_text(fake)
        return

    # å°æ¸¬é©—é–‹å§‹
    if data == "quiz:start":
        start_quiz(uid)
        qdata, idx, score = get_quiz_state(uid)
        send_quiz_question_reply(event, qdata, idx)
        return

    # å°æ¸¬é©—å›ç­”
    if data.startswith("quiz:ans:"):
        _, _, idx_s, opt_s = data.split(":")
        idx = int(idx_s)
        chosen = int(opt_s)

        state = get_quiz_state(uid)
        if not state:
            return

        qdata, _, score = state
        correct_idx = qdata[idx]["answer"]
        ok = (chosen == correct_idx)

        if ok:
            score += 1

        # 1ï¸âƒ£ å›é¥‹ï¼ˆreplyï¼‰
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=feedback(ok)))

        next_idx = idx + 1
        total = len(qdata)

        # 2ï¸âƒ£ å¦‚æœé‚„æœ‰ä¸‹ä¸€é¡Œ â†’ push é¡Œç›®
        if next_idx < total:
            update_quiz_state(uid, next_idx, score)
            send_quiz_question_push(uid, qdata, next_idx)
            return

        # 3ï¸âƒ£ æ¸¬é©—å®Œæˆ â†’ push æˆç¸¾ï¼‹ä¸»é¸å–®
        percent = int(score * 100 / total)
        summary = (
            f"ğŸ‰ å°æ¸¬é©—å®Œæˆï¼\n\n"
            f"å¾—åˆ†ï¼š{score}/{total}\n"
            f"æ­£ç¢ºç‡ï¼š{percent}%\n\n"
            f"ä½ å·²ç¶“æŒæ¡ä¸å°‘è¶…æ…¢è·‘è§€å¿µäº†ï¼Œå¾ˆæ£’ï¼"
        )

        # è¨˜éŒ„æˆç¸¾
        with sqlite3.connect(DB_PATH) as conn:
            c = conn.cursor()
            c.execute("""
            INSERT INTO quiz_result(user_id, score, total, percent, finished_at)
            VALUES (?, ?, ?, ?, ?)
            """, (uid, score, total, percent, datetime.utcnow().isoformat()))
            conn.commit()

        line_bot_api.push_message(uid, TextSendMessage(summary))
        line_bot_api.push_message(uid, main_visual())
        line_bot_api.push_message(uid, menu_flex())
        return
    
    # ------------------------------------------------------------
    # åœ‹å¥ç½²ï¼šé»åˆ†é¡å¾Œé¡¯ç¤ºç¬¬ 1 ç¯‡
    # ------------------------------------------------------------
    if data.startswith("mohw_cat:"):
        cat = data.split(":")[1]

        articles = load_mohw_group().get(cat, [])
        if not articles:
            line_bot_api.push_message(uid, TextSendMessage("é€™å€‹åˆ†é¡ç›®å‰æ²’æœ‰æ–‡ç« å–”ï½"))
            return

        idx = 0
        send_mohw_article(uid, articles, idx)
        return

    # ------------------------------------------------------------
    # åœ‹å¥ç½²ï¼šä¸‹ä¸€ç¯‡
    # ------------------------------------------------------------
    if data.startswith("mohw_next:"):
        _, cat, idx_s = data.split(":")
        idx = int(idx_s) + 1

        articles = load_mohw_group().get(cat, [])
        if not articles:
            return

        if idx >= len(articles):
            idx = 0  # å¾é ­é–‹å§‹

        send_mohw_article(uid, articles, idx)
        return

    # ------------------------------------------------------------
    # åœ‹å¥ç½²ï¼šä¸Šä¸€ç¯‡
    # ------------------------------------------------------------
    if data.startswith("mohw_prev:"):
        _, cat, idx_s = data.split(":")
        idx = int(idx_s) - 1

        articles = load_mohw_group().get(cat, [])
        if not articles:
            return

        if idx < 0:
            idx = len(articles) - 1

        send_mohw_article(uid, articles, idx)
        return
        


# ================================================================
#                     Exercise Log
# ================================================================
def record_today(uid):
    today = datetime.utcnow().strftime("%Y-%m-%d")
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("INSERT INTO run_log(user_id, run_date) VALUES (?, ?)", (uid, today))
        conn.commit()


def get_week_stat(uid):
    seven_days_ago = datetime.utcnow() - timedelta(days=7)
    start_day = seven_days_ago.strftime("%Y-%m-%d")

    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT run_date FROM run_log WHERE user_id=? AND run_date>=?",
                  (uid, start_day))
        rows = c.fetchall()

    return len(set(r[0] for r in rows))


# ================================================================
#                     Article Card
# ================================================================
def make_article(title, content):
    bubble = {
        "type": "bubble",
        "size": "mega",
        "body": {
            "type": "box",
            "layout": "vertical",
            "contents": [
                {"type": "text", "text": title, "weight": "bold", "size": "lg"},
                {"type": "text", "text": content, "wrap": True, "margin": "md"}
            ]
        }
    }
    return FlexSendMessage(title, bubble)


# ================================================================
#                     Text Message Handler
# ================================================================
@handler.add(MessageEvent, message=TextMessage)
def handle_text(event):
    text = event.message.text.strip()
    uid = event.source.user_id

    # ä¸»é¸å–®
    if text in ["é–‹å§‹", "ä¸»é¸å–®", "menu"]:
        line_bot_api.reply_message(event.reply_token, main_visual())
        line_bot_api.push_message(uid, menu_flex())
        return

    # è¡›æ•™å…§å®¹
    if text in ["é—œæ–¼è¶…æ…¢è·‘", "about"]:
        a = get_random_article("about")
        line_bot_api.reply_message(event.reply_token, make_article(a["title"], a["content"]))
        return

    if text in ["é£²é£Ÿå»ºè­°", "diet"]:
        a = get_random_article("diet")
        line_bot_api.reply_message(event.reply_token, make_article(a["title"], a["content"]))
        return

    if text in ["é‹å‹•å»ºè­°", "exercise"]:
        a = get_random_article("exercise")
        line_bot_api.reply_message(event.reply_token, make_article(a["title"], a["content"]))
        return
    
    # åœ‹å¥ç½²æ–‡ç« 
    if text in ["åœ‹å¥ç½²æ–‡ç« ", "mohw"]:
        line_bot_api.reply_message(event.reply_token, mohw_category_menu())
        return

    # é‹å‹•ç´€éŒ„
    if text == "æˆ‘ä»Šå¤©æœ‰é‹å‹•":
        record_today(uid)
        line_bot_api.reply_message(event.reply_token, TextSendMessage("å¤ªæ£’äº†ï¼æˆ‘å·²è¨˜éŒ„ä»Šå¤©çš„é‹å‹• ğŸŒŸ"))
        return

    # æœ¬é€±çµ±è¨ˆ
    if text == "æœ¬é€±çµ±è¨ˆ":
        days = get_week_stat(uid)
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(f"ä½ æœ€è¿‘ 7 å¤©æœ‰é‹å‹• {days} å¤©ï¼æŒçºŒåŠ æ²¹ ğŸ’ª")
        )
        return
    


    # fallback
    line_bot_api.reply_message(
        event.reply_token,
        TextSendMessage(
            "æˆ‘æ‡‚çš„æŒ‡ä»¤æœ‰ï¼šé–‹å§‹ã€å°æ¸¬é©—ã€é—œæ–¼è¶…æ…¢è·‘ã€é£²é£Ÿå»ºè­°ã€é‹å‹•å»ºè­°ã€æˆ‘ä»Šå¤©æœ‰é‹å‹•ã€æœ¬é€±çµ±è¨ˆã€‚\n\nå…ˆå¸¶ä½ å›ä¸»é¸å–®ï½"
        )
    )
    line_bot_api.push_message(uid, main_visual())
    line_bot_api.push_message(uid, menu_flex())


    


# ================================================================
#                          Main
# ================================================================
if __name__ == "__main__":
    init_db()
    port = int(os.getenv("PORT", 5001))
    app.run(host="0.0.0.0", port=port)